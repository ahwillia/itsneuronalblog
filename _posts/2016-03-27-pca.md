---
layout: post
title: Everything you did and didn't know about PCA
comments: True
author: alex_williams
completed: True
topic: Dimensionality Reduction
post_description: Many scientists are familiar with organizing and handling data in 2D tables. For example, we might record the mRNA expression level of $p$ genes in $n$ tissue samples. We might store these data in a $n \times p$ matrix, where each row corresponds to a sample, and each column corresponds to a gene. Principle components analysis (PCA) is a standard way to reduce the dimension $p$ (which can be quite large) to something more manageable. <br><br> While it is quite common for biologists to apply PCA to their data, it is less common for them to really understand the mechanics and assumptions implicit in this analysis. Opening up the black box on a statistical technique is worthwhile in and of itself, but the real reason I'm motivated to write this is the number of seriously cool and super useful extensions/variations of PCA (e.g., <a href="https://en.wikipedia.org/wiki/Non-negative_matrix_factorization" target="_blank">Non-negative matrix factorization</a>, <a href="https://en.wikipedia.org/wiki/Sparse_PCA" target = "_blank">Sparse PCA</a>, <a href="http://dx.doi.org/10.1137/07070111X" target="_blank">Tensor Decompositions</a>), which will have a growing impact on modern neuroscience and biology. I want to blog about techniques of this flavor for the next few posts.
---

### Contents
{:.no_toc}
* TOC
{:toc}

### Intro

Many scientists are familiar with organizing and handling data in 2D tables. For example, we might record the mRNA expression level of $p$ genes in $n$ tissue samples. We might store these data in a $n \times p$ matrix, where each row corresponds to a sample, and each column corresponds to a gene. Principle components analysis (PCA) is a standard way to reduce the dimension $p$ (which can be quite large) to something more manageable.

While it is quite common for biologists to apply PCA to their data, it is less common for them to really understand the mechanics and assumptions implicit in this analysis. Opening up the black box on a statistical technique is worthwhile in and of itself, but the real reason I'm motivated to write this is the number of seriously cool and super useful extensions/variations of PCA (e.g., [Non-negative matrix factorization](https://en.wikipedia.org/wiki/Non-negative_matrix_factorization), [Sparse PCA](https://en.wikipedia.org/wiki/Sparse_PCA), [Tensor Decompositions](http://dx.doi.org/10.1137/07070111X)), which will have a growing impact on modern neuroscience and biology. I want to blog about techniques of this flavor for the next few posts.

If you are completely unfamiliar with PCA, there [are](http://www.stat.cmu.edu/~cshalizi/350/lectures/13/lecture-13.pdf) [some](https://www.cs.princeton.edu/picasso/mats/PCA-Tutorial-Intuition_jp.pdf) [great](http://www.cs.otago.ac.nz/cosc453/student_tutorials/principal_components.pdf) [explanations](http://sebastianraschka.com/Articles/2015_pca_in_3_steps.html) [online](http://jeremykun.com/2012/06/28/principal-component-analysis/) that you should reference concurrently with reading this post. While these materials are quite good, many of them don't explain PCA in a way that naturally lends itself to more complex (but fun and useful!) extensions.

I aimed to be as pedagogical as possible in this post, but you will need to be familiar with some linear algebra to follow along. You don't need to know what an eigenvalue is (though it will help you understand certain results more deeply), but [basic matrix operations](https://www.youtube.com/watch?v=kT4Mp9EdVqs) are needed. Also, go teach yourself what an eigenvalue is, it's good for you.

If you think you're already a PCA whiz and don't care for the background stuff, you can skip to [some things you maybe didn't know about PCA](#some-things-you-maybe-didnt-know-about-pca) or just [read the tl;dr](#tldr).


### Notation

* Capital letters = matrices (e.g. $A$)
* Lowercase letters = scalars (e.g. $n$, $p$)
* Boldface lowercase = column vectors (e.g. $\mathbf{c}$)
* Superscript $T$ = [transpose operator](https://en.wikipedia.org/wiki/Transpose) (e.g. $\mathbf{c}^T$, $A^T$)
* Subscripts = element position (e.g. $A_{ij}$ is the scalar in row $i$ column $j$)

Throughout, we suppose that we have a matrix of data $A$ with dimensions $n \times p$, where $n$ is the number of observations, and $p$ is the number of features that are measured and associated with each observation. For example, we might record $n$ neurons and estimate their firing rate at $p$ timepoints; or we might measure the expression of $p$ genes across $n$ cells.

### Everything you did know (or do now)

PCA tries to find "components" that capture the maximal variance within the data. For 2 dimensional data, this is the basic image you may have come across:

{% include image.html url="/itsneuronalblog/img/pca/pca_classic.png" width="300px" title="Classic view of PCA." description="Each blue point corresponds to an observation (a row of $A$). There are $n=20$ observations, each with $p=3$ features. In this schematic, PCA reduces the dimensionality from three to $r=2$. In particular, it finds a pair of orthogonal vectors (red arrows) that define a lower-dimensional space (grey plane) which captures as much variance as possible from the original dataset."%}

Now let's express the above picture mathematically. Assume that each column of $A$ has been mean subtracted so that the datapoints are centered around the origin. Then finding the direction of maximal variance (i.e. the *first* principal component) corresponds to solving the following optimization problem

$$
\begin{equation}
\begin{aligned}
& \underset{\mathbf{c}}{\text{maximize}}
& & \mathbf{c}^T A^T A \mathbf{c} \\
& \text{subject to}
& & \mathbf{c}^T \mathbf{c} = 1
\end{aligned}
\end{equation}
$$

Why does $\mathbf{c}^T A^T A \mathbf{c}$ measure the variance we want to maximize? Let $\mathbf{w} = A \mathbf{c}$, which is the [projection of each datapoint](https://www.youtube.com/watch?v=27vT-NWuw0M) onto the top principal component (since we imposed $\mathbf{c}^T \mathbf{c} = 1$). Because the data have been mean subtracted, the variance of the projected data is $\mathbf{w}^T \mathbf{w}$, which equals the objective function $\mathbf{c}^T A^T A \mathbf{c}$.{%include footnote.html n=1 %} The vector $\mathbf{c}$ is the top principal component, and the vector $\mathbf{w}$ contains the "loadings" for each observation along this axis.

There are a few ways to solve this optimization problem to determine $\mathbf{c}$ and $\mathbf{w}$. The classic approach would be to compute the eigenvalues of $A^T A$ (the [covariance matrix](https://en.wikipedia.org/wiki/Covariance_matrix) with dimensions $p \times p$) and set $\mathbf{c}$ to the eigenvector associated with the largest eigenvalue.{%include footnote.html n=2 %} This is more-or-less what happens under the hood when you call pca() in MATLAB or python &mdash; the eigendecomposition of the covariance matrix is computed via the [singular value decomposition (SVD)](https://en.wikipedia.org/wiki/Singular_value_decomposition). It turns out that this approach does not work for tensors, matrices with incomplete data, or many other interesting cases.

Let's assume that we solve the optimization problem (1) by some method. Then our best approximation of the data is the [outer product](https://en.wikipedia.org/wiki/Outer_product) of $\mathbf{w}$ and $\mathbf{c}$:

$$
A \approx \mathbf{w} \mathbf{c}^T \quad \text{or} \quad  A_{ij} \approx w_i c_j
$$

This is called a rank-one reconstruction of the data because $\mathbf{w} \mathbf{c}^T$ produces a matrix with rank=1 ([*click here for explanation of matrix rank*](https://www.youtube.com/watch?v=JUgrBkPteTg)). Visually, our reconstruction looks something like this:

{% include image.html url="/itsneuronalblog/img/pca/rank_one.png" width="600px" title="Example reconstruction of data with 1 principal component." description="An example data matrix (<i>left</i>) with $n=12$ observations and $p=8$ features is approximated by the outer product $\mathbf{w} \mathbf{c}^T$ (<i>middle</i>) which produces a rank-one matrix (<i>right</i>). Note $\mathbf{w}$ is labeled as <i>loadings</i> and $\mathbf{c}^T$ is labeled as <i>component</i>"%}

Most data can't be well-described by a single principal component. Typically, we compute multiple principal components by computing all eigenvectors of $A^T A$ and ranking them by their eigenvalues. This can be visualized by a *scree plot*, which plots the variance explained by each successive principal component. People may have told you to look for the "knee" or inflection point in the scree plot to determine the number of components to keep (the rest are noise). ***Spoiler alert:** you can do better than this, and we'll see how by the end of the post.*

{% include image.html url="/itsneuronalblog/img/pca/scree.png" width="300px" title="Scree plot." description="Principal components are ranked by the amount of variance they capture in the original dataset, a scree plot can provide some sense of how many components are needed." %}

We can organize the top $r$ principal components into a matrix $C = [ \mathbf{c}_1, \mathbf{c}_2, ... , \mathbf{c}_r ]$ and the loading weights into $W = [\mathbf{w}_1, \mathbf{w}_2, ... , \mathbf{w}_r ]$. Our reconstruction of the data is now a sum of $r$ outer products:

$$
A \approx \sum_{k=1}^r \mathbf{w}_k \mathbf{c}_k^T \quad \text{or} \quad A \approx W C^T
$$

{% include image.html url="/itsneuronalblog/img/pca/pca_3.png" width="600px" title="Example reconstruction of data with 3 principal components." description="A data matrix (<i>left</i>) is approximated by the product of a $n \times r$ matrix and a $r \times p$ matrix (i.e. $W C^T$). This product is at most a rank-$r$ matrix (in this example, $r=3$). Each paired column of $W$ and row of $C^T$ form an outer product, so the full reconstruction can also be thought of as a sum of $r$ rank-one matrices."%}

Each row of the components matrix, $C^T$, is a principal component, which is a mixture of the $p$ features measured in the dataset. Each row of the loadings matrix, $W$, provides a recipe for combining the $r$ components to approximately reconstruct a single datapoint (i.e. a row in $A$). For example, if row $i$ of $W$ was $[1, 2, -1]$, then our estimate for row $i$ of $A$ would be: $ \mathbf{c}_1 + 2 \mathbf{c}_2 - \mathbf{c}_3 $ where the $\mathbf{c}$'s are the top three components (the rows of $C^T$). That is, our reconstruction for the data at row $i$, column $j$ is simply a linear combination of the components:

$$
A_{ij} \approx \sum_{k=1}^r W_{ik} C_{jk}
$$

### An alternative optimization problem

As discussed above, a classic perspective is that PCA finds a set of directions (technically, a linear subspace) that maximizes the variance of the data once it is projected into that space. It turns out that this is equivalent to finding a linear subspace that minimizes the distance of the projection in a least-squares sense.{%include footnote.html n=3%}

{% include image.html url="/itsneuronalblog/img/pca/pca_two_views.png" width="600px" title="Two equivalent views of principal component analysis." description=""%}

In this second perspective on PCA, we can find the top $r$ principal components $C$ by solving:

$$
\begin{equation}
\begin{aligned}
& \underset{C}{\text{minimize}}
& & \lVert A - A C C^T \lVert_F^2 \\
& \text{subject to}
& & C^T C = I
\end{aligned}
\end{equation}
$$

As before, the loadings are a $n \times r$ matrix holding the projected data ($W = A C$), our reconstruction is a rank-$r$ matrix ($A \approx A C C^T = W C^T$). Above, $\lVert \cdot \lVert_F^2$ denotes the squared [Frobenius norm](http://mathworld.wolfram.com/FrobeniusNorm.html), which sounds fancy,{%include footnote.html n=4 %} but it is just the sum of squared residuals:

$$
\lVert A - W C^T \lVert_F^2 = \sum_{i=1}^n \sum_{j=1}^p (A_{ij} - \sum_{k=1}^K W_{ik} C_{jk})^2 
$$

Why is minimizing squared residuals equivalent to maximizing variance? Consider a datapoint $\mathbf{a}_i$ (row $i$ of $A$). Then the contribution of that datapoint to the variance is $\mathbf{a}_i^T \mathbf{a}_i$, or equivalently the squared [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance) $\lVert \mathbf{a}_i \lVert^2_2$. Applying the Pythagorean theorem shows that this total variance equals the sum of variance lost (the squared residual) and variance remaining. Thus, it is equivalent to either maximize remaining variance or minimize lost variance to find the principal components. The figure below visualizes this for 2 dimensions:

{% include image.html url="/itsneuronalblog/img/pca/projection_intuition.png" width="600px" title="Maximizing variance in principal component space is equivalent to minimizing least-squares reconstruction error." description="Consider a datapoint $\mathbf{a}_i$ (row $i$ of the data matrix $A$). Assuming the data are mean-centered, the projection of $\mathbf{a}_i$ onto the principal components relates the remaining variance to the squared residual by the Pythagorean theorem. Choosing the components to maximize variance is the same as choosing them to minimize the squared residuals."%}

### Generalizations of PCA: sparse features, loss functions

Thinking about PCA as minimizing reconstruction error is useful because it draws a connection to statistical regression.{% include footnote.html n=5 %} Simple least-squares linear regression has been extended and adapted to a wide variety of statistical problems ([*see GLMs*](https://en.wikipedia.org/wiki/Generalized_linear_model)), and we can leverage this research framework and perspective to come up with more specialized versions of PCA. This general framework has been developed my a number of papers ([Collins, 2001](http://papers.nips.cc/paper/2078-a-generalization-of-principal-components-analysis-to-the-exponential-family.pdf); [Gordon, 2004](http://papers.nips.cc/paper/2144-generalized2-linear2-models.pdf); [Udell, 2015](https://courses2.cit.cornell.edu/mru8/doc/udell15_thesis.pdf)). Below is a whirlwind tour:

We will start with **quadratically regularized PCA**, which is similar to [ridge regression](https://en.wikipedia.org/wiki/Tikhonov_regularization). The basic idea is to penalize the squared [Euclidean length (L2 norm)](https://en.wikipedia.org/wiki/Norm_(mathematics)#Euclidean_norm) of the rows of $W$ and $C$ so that they don't get too large:

$$
\begin{equation}
\begin{aligned}
& \underset{W,C}{\text{minimize}}
& & \lVert A - W C^T \lVert_F^2 ~+~ \gamma \sum_{i=1}^n \lVert \mathbf{w}_i \lVert_2^2 ~+~ \gamma \sum_{j=1}^p \lVert \mathbf{c}_j \lVert_2^2 \\
\end{aligned}
\end{equation}
$$

[Madeleine Udell's thesis](https://courses2.cit.cornell.edu/mru8/doc/udell15_thesis.pdf) shows that the answer to this problem is very similar to classic PCA and can be solved analytically using the [singular value decomposition (SVD)](https://en.wikipedia.org/wiki/Singular_value_decomposition).

Interestingly, the rest of the PCA variants listed in this post cannot be analytically solved. In fact, PCA and quadratically-regularized PCA are quite [*special cases of nonconvex optimization problems that we can solve exactly*](https://youtu.be/7clclzk3hrw?t=29m40s). In practice, we can still fit the rest of these models using standard techniques like gradient descent. Even better, we can exploit the fact that ***these optimization problems are [biconvex](http://www2.math.uni-wuppertal.de/~klamroth/publications/gopfkl07.pdf)***. That is, if we treat $W$ as a fixed constant and optimize over $C$ then the problem is [convex](https://en.wikipedia.org/wiki/Convex_optimization), and vice versa. This suggests the [alternating minimization algorithm](http://arxiv.org/pdf/1312.0925v3.pdf) which can work very well in practice. In rough pseudocode:

<hr>

> **Alternating minimization:**<br>
> 1 &nbsp;&nbsp;&nbsp;&nbsp; choose initial starting points $W^{(0)}$ and $C^{(0)}$<br>
> 2 &nbsp;&nbsp;&nbsp;&nbsp; $n \leftarrow 0$<br>
> 3 &nbsp;&nbsp;&nbsp;&nbsp; **while** not converged<br>
> 4 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; $W^{(n+1)} \leftarrow $ minimize over $W$ while holding $C = C^{(n)}$ constant.<br>
> 5 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; $C^{(n+1)} \leftarrow $ minimize over $C$ while holding $W = W^{(n+1)}$ constant.<br>
> 6 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; $n \leftarrow n+1$<br>
> 7 &nbsp;&nbsp;&nbsp;&nbsp; **end while**

<hr>

Again, the idea here is that the sub-problems (4) and (5) are easy to optimize because they are convex. It isn't necessary to minimize the sub-problems to completion, in fact it can work better to take just take alternating gradient steps for each sub-problem.

**Sparse PCA.** If we substitute a [L1 norm](https://en.wikipedia.org/wiki/Taxicab_geometry) penalty for the L2 norm regularization we encounter a form of [sparse PCA](https://web.stanford.edu/~hastie/Papers/spc_jcgs.pdf):

$$
\begin{equation}
\begin{aligned}
& \underset{W,C}{\text{minimize}}
& & \lVert A - W C^T \lVert_F^2 ~+~ \gamma \sum_{i=1}^n \lVert \mathbf{w}_i \lVert_1 ~+~ \gamma \sum_{j=1}^p \lVert \mathbf{c}_j \lVert_1 \\
\end{aligned}
\end{equation}
$$

This problem is similar to [LASSO](https://en.wikipedia.org/wiki/Lasso_(statistics)) and [elastic net](https://en.wikipedia.org/wiki/Elastic_net_regularization) regression. Typically, this penalty/regularization choice causes the best $W$ and $C$ to be sparse (i.e. have many zero entries). This can be helpful for interpretation. For example, if we have a gene expression dataset then we may want to limit ourselves so that each component &mdash; column of $C$ &mdash; only contains a handful of genes, rather than a large combination of all genes (which can be quite large). This is demonstrated in the figure below from [D'Aspremont et al. (2007)](http://dx.doi.org/10.1137/050645506):

{%include image.html url="/itsneuronalblog/img/pca/sparse_pca.png" width="600px" title="Sparse PCA produces similar results to PCA, but with simpler and more interpretable components." description="500 genes were measured for a large number of samples. The factors $f_1$, $f_2$, $f_3$ obtained by traditional PCA each use all 500 genes (<i>left</i>). The sparse factors $g_1$, $g_2$, and $g_3$ on the right together involve only 14 genes, which can be useful for developing parsimonious hypotheses and future experiments. Both PCA and Sparse PCA separate the three tissue types that were measured; the color of each datapoint corresponds to the tissue type. The separation is slighly larger for PCA, but is less interpretable. Figure reproduced from <a href='http://dx.doi.org/10.1137/050645506'>D'Aspremont et al. (2007)</a>, data from Iconix Pharmaceuticals." %}

**Non-negative matrix factorization.** Another popular dimensionality technique is [non-negative matrix factorization (NMF)](http://dx.doi.org/10.1038/44565), which is similar to [non-negative least-squares](https://en.wikipedia.org/wiki/Non-negative_least_squares) regression. Again, this looks very similar PCA, the only difference being that we constrain/demand each element of $W$ and $C$ to be nonnegative:

$$
\begin{equation}
\begin{aligned}
& \underset{W,C}{\text{minimize}}
& & \lVert A - W C^T \lVert_F^2 \\
& \text{subject to}
& & W_{ik} \geq 0,~ C_{jk} \geq 0
\end{aligned}
\end{equation}
$$

This typically only makes sense when your data is also nonnegative, $A_{ij} \geq 0$, since the reconstructed estimate for each datapoint is clearly nonnegative when both $W$ and $C$ are nonnegative. Like sparse PCA, NMF can lead to a more interpretable dimensionality reduction since it forces only additive, not subtractive, combinations of the components. (PCA reconstructs the dataset by both additive and subtractive combinations of components.) NMF is an central part of the calcium imaging analysis pipeline recently published by Liam Paninski's group [(Pnevmatikakis et al., 2016)](http://dx.doi.org/10.1016/j.neuron.2015.11.037).

**Logistic PCA.** We can also replace squared error with different loss functions. For example, suppose you sequence the genomes of $n$ patients and check $p$ nucleotide sites for mutations ($A_{ij} = 1$ if patient $i$ has a mutation at site $j$, and $A_{ij} = -1$ if there is not mutation). Because your data is *binary* you might use [logistic PCA](http://research.microsoft.com/en-us/um/cambridge/events/aistats2003/proceedings/119.pdf), which is similar to [logistic regression](https://en.wikipedia.org/wiki/Logistic_regression):

$$
\begin{equation}
\begin{aligned}
& \underset{W,C}{\text{minimize}}
& & \sum_{i=1}^n \sum_{j=1}^p  \log ( 1 + \exp(-A_{ij} \cdot \sum_{k=1}^r W_{ik} C_{jk} )) \\
\end{aligned}
\end{equation}
$$

Why use logistic PCA? When we have binary data, modeling the output as a linear combination of factors/components doesn't make a whole lot of sense: the data are either $A_{ij} = \\{+1,-1\\}$, but $\mathbf{w}^T_i \mathbf{c}_j$ could be much larger or smaller than these bounds. For a longer explanation, read up on [when/why to use logistic regression instead of linear regression](http://stats.stackexchange.com/questions/29325/what-is-the-difference-between-linear-regression-and-logistic-regression) &mdash; the reasoning is exactly analogous. It is also informative to compare classic to logistic PCA on simulated binary data, as shown in the plot below:

{% include image.html url="/itsneuronalblog/img/pca/logistic_pca.png" width="600px" title="Logistic PCA can outperform classic PCA on binary data." description="See <a href='/itsneuronalblog/code/pca/lgc_pca.jl' target='_blank'>Julia code here</a> to reproduce this figure." %}

There are many other variations that you can come up with, each of which is tailored to different data types and characteristics:

**Robust PCA.** If you have outliers in your dataset, use the sum of the absolute value of the residuals (L1 loss) or a [Huber loss](https://en.wikipedia.org/wiki/Huber_loss) function ([Kwak, 2008](http://dx.doi.org/10.1109/TPAMI.2008.114)). There are some alternative formulations of robust PCA, see e.g. [Candes et al. (2009)](http://statweb.stanford.edu/~candes/papers/RobustPCA.pdf) and [Netrapalli et al. (2014)](http://papers.nips.cc/paper/5430-non-convex-robust-pca.pdf).

**Poisson PCA and PCA on ordinal data.** See [Rennie &amp; Srebro (2005)](http://qwone.com/~jason/papers/ijcai05-preference.pdf) for some discussion of appropriate loss functions.

**Zero-Inflated dimensionality reduction.** Some datasets, such those from single-cell RNAseq, have more zero entries than would be expected under a Poisson noise model. This can arise from technical variability &mdash; mRNA is fragile, and lowly expressed genes have less starting material, leading to "dropout" of lowly expressed genes to zero. [Pierson &amp; Yau (2015)](http://dx.doi.org/10.1186/s13059-015-0805-z) develop a model to account for this flavor of noise, and their work can be mapped onto the optimization framework described in this post.

**All of these methods have the same basic flavor:**

* We start with a 2D array of data $A$
* We define some cost function or objective function that measures the fit (e.g. least-squares or logistic loss)
* If we want, we can add terms to the cost function regularize the problem (e.g. to encourage sparsity or enforce nonnegativity)
* We optimize two smaller matrices $W$ and $C^T$ so that their product reconstructs the data as best as possible.
* The optimization problem is [biconvex](http://www2.math.uni-wuppertal.de/~klamroth/publications/gopfkl07.pdf) (unless the regularization terms or constraints aren't convex) suggesting alternating minimization as a reasonable optimization procedure

In the next post we'll see that this basic procedure extends quite nicely to other data structures. For example, sometimes our data is more naturally represented in a 3D array (i.e. a ***tensor***), rather than a matrix. We can apply similar optimization schemes to reduce the dimensionality of the data in this case.

### Some things you maybe didn't know about PCA

#### PCA overfits to noise if $p > n$ (i.e. it is an [inconsistent](https://en.wikipedia.org/wiki/Consistent_estimator) estimator of the subspace of maximal variance).
{:.no_toc}

When solving linear systems of equations the number of equations must be greater than then number of unknown variables. In linear regression, this means that we need more observations than unknown variables ($n > p$). We've seen that PCA is closely related to regression, and so it should come as no big surprise that PCA runs into problems when $p > n$. Intuitively, each dimension/feature has some noise associated with it, and we need more observations than parameters to reliably tease apart the signal from the noise. 

One way to potentially get around this problem is to use sparse PCA ([Johnston &amp; Lu, 2009](http://dx.doi.org/10.1198/jasa.2009.0121)), although this assumes that your dataset is well-represented in a sparse basis. Moreover, you shouldn't blindly assume that L1 regularization will produce the *correct* sparsity pattern ([Su et al., 2015](http://statweb.stanford.edu/~candes/papers/LassoFDR.pdf); [Advani &amp; Ganguli, 2016](http://arxiv.org/abs/1601.04650)).

#### There is a very good and simple procedure to determine how many principal components to keep
{:.no_toc}

A primary motivation behind PCA is to use as few components as possible to *reduce* the dimensionality of the data we are working with. Thus, we are often interested in truncating PCA &mdash; keep only the top $k$ components and throw away the rest. There are at least two reasons for this:

* Truncating gives us a sense of how complex the dataset is. If the top two principal components capture a large majority of variance, then the dataset is more-or-less two-dimensional.{%include footnote.html n=6 %}

* Truncating denoises the data. The conceptual connection of PCA to regression is again helpful here &mdash; PCA is analogous to fitting a smooth curve through noisy data. Similar intuition is given by figure 2 in this blog post, in which a rank-1 approximation gives a smooth, less noisy, representation of the data.

The question then becomes, how do we choose where to truncate? This used to be one of those classic questions with an unsatisfying answer... Basically, eyeball it.

[Gavish &amp; Donoho (2014)](http://dx.doi.org/10.1109/TIT.2014.2323359) present a long overdue result on this problem and their answer is surprisingly simple and concrete. Essentially, the optimal{%include footnote.html n=7 %} procedure boils down to estimating the noise in the dataset, $\sigma$, and then throwing away all components whose singular values are below a specified threshold. For a square $n \times n$ matrix, this threshold is:

$$\lambda =  \frac{4\sigma\sqrt{n}}{\sqrt{3}}$$

There is a similar threshold for non-square datasets explained in the paper. As with any theoretical study, the result comes with a few assumptions and caveats,{%include footnote.html n=8 %} but their work appears robust and useful in practice.

***Edit:*** Thanks to Jonathan Pillow for pointing out a Bayesian alternative outlined here: [*Minka (2000). Automatic choice of dimensionality for PCA*](http://hd.media.mit.edu/tech-reports/TR-514.pdf)

#### PCA becomes [non-trivial](http://epubs.siam.org/doi/abs/10.1137/110820361) to solve when data entries are missing
{:.no_toc}

After thinking about these topics for a while, I found it pretty incredible that PCA works at all. In the first place, it is pretty special any time you can provably and analytically solve a nonconvex optimization problem.

The specialness of PCA breaks down even under pretty mild perturbations. [Ilin &amp; Raiko (2010)](http://www.jmlr.org/papers/volume11/ilin10a/ilin10a.pdf) discuss a nice illustration of this point. Consider the case where some subset of data entries are not observed $A_{ij} = \text{NA}$. Even if you keep the ordinary PCA objective function, a number of problems arise:

* There is no analytical solution because the data covariance matrix is nontrivial to estimate
* The objective function contains local minima (unlike in classic PCA, where there are only saddle points and one global minimum). Thus, it is difficult to certify that the output of your optimization problem is true solution to the problem.
* There is no analytical solution even for the bias term, in contrast to classic PCA where the bias equals column-wise mean of the data matrix.

This last one is particularly jarring. It feels so natural to mean-center the data that is easy to forget that this is not always justified. The task of estimating missing data entries is known as [*matrix completion*](https://en.wikipedia.org/wiki/Matrix_completion) and is an important problem in the machine learning community (see [*Netflix Prize*](https://en.wikipedia.org/wiki/Netflix_Prize), [Candes &amp; Recht, 2008](http://statweb.stanford.edu/~candes/papers/MatrixCompletion.pdf)). Alternating minimization is a common approach for solving these problems (e.g., [Jain et al., 2013](http://dx.doi.org/10.1145/2488608.2488693)).

### TL;DR

* PCA finds low-dimensional projections that maximally preserve variance in the data
* This is equivalent to finding a projection that minimizes the projection distance in a least-squares sense
* This second formulation is similar to least-squares regression. Thinking about PCA this way helps because really smart statisticians have spent decades characterizing, generalizing, robustifying regression. Natural extensions of PCA in this framework include:
	* [Sparse PCA](https://web.stanford.edu/~hastie/Papers/spc_jcgs.pdf), similar to [LASSO](https://en.wikipedia.org/wiki/Lasso_(statistics)) in regression
	* [Non-negative matrix factorization](http://dx.doi.org/10.1038/44565), similar to [non-negative least squares](https://en.wikipedia.org/wiki/Non-negative_least_squares)
	* [Logistic PCA](http://research.microsoft.com/en-us/um/cambridge/events/aistats2003/proceedings/119.pdf) for binary data, similar to [Logistic regression](https://en.wikipedia.org/wiki/Logistic_regression)
	* A variety of [tensor decompositions](http://epubs.siam.org/doi/pdf/10.1137/07070111X)
* PCA is not always easy:
	* When there are fewer replicates/samples than measured features/variables ($p > n$) PCA is an [inconsistent estimator](http://dx.doi.org/10.1198/jasa.2009.0121). You need to regularize the problem somehow.
	* When there are missing data entries PCA is [provably NP-hard](http://dx.doi.org/10.1137/110820361).
* How do you choose the number of principal components to keep?
	* It isn't as necessarily hard as you think. [Gavish &amp; Donoho (2014)](http://dx.doi.org/10.1109/TIT.2014.2323359) describe an easy procedure to truncate all components below a threshold based on the level of noise in your data.

### Further Reading

* Udell et al. (2015). [Generalized Low-Rank Models](http://arxiv.org/abs/1410.0342). *arxiv preprint*
* Tipping &amp; Bishop (1999). [Probabilistic principal component analysis](http://dx.doi.org/10.1111/1467-9868.00196). *Journal of the Royal Statistical Society: Series B*
* Ilin &amp; Raiko (2010). [Practical Approaches to Principal Component Analysis in the Presence of Missing Values](http://www.jmlr.org/papers/volume11/ilin10a/ilin10a.pdf). *Journal of Machine Learning Research*
* Gordon (2002). [Generalized<sup>2</sup> Linear<sup>2</sup> Models](http://www.cs.cmu.edu/~ggordon/ggllm.pdf). *NIPS*
* Cunningham &amp; Ghahramani (2015) [Linear dimensionality reduction: survey, insights, and generalizations](http://jmlr.org/papers/volume16/cunningham15a/cunningham15a.pdf) *Journal of Machine Learning Research*
* Burges (2009). [Dimension Reduction: A Guided Tour](http://dx.doi.org/10.1561/2200000002). *Foundations and Trends in Machine Learning*

{% include sharebar.html %}

#### Footnotes
{:.no_toc}
<p class="footnotes" markdown="1">
{% include foot_bottom.html n=1 %} It is a basic property of the transpose operator that $(A \mathbf{c})^T = \mathbf{c}^T A^T$.
</p>
<p class="footnotes" markdown="1">
{% include foot_bottom.html n=2 %} There are many interesting remarks to make for the aficionados. Note that the covariance matrix $Q = A^T A$ is a symmetric, [positive semi-definite matrix](https://en.wikipedia.org/wiki/Positive-definite_matrix). This means that $\mathbf{z}^T Q \mathbf{z} \geq 0$ for any vector $\mathbf{z}$, and equivalently that all eigenvalues of $Q$ are nonnegative. PCA maximizes $\mathbf{w}^T Q \mathbf{w}$; the [solution to this problem](http://math.stackexchange.com/questions/23596/why-is-the-eigenvector-of-a-covariance-matrix-equal-to-a-principal-component) is to set $\mathbf{w}$ to the eigenvector of $Q$ associated with the largest eigenvalue. All [symmetric matrices have orthogonal eigenvectors](http://math.stackexchange.com/questions/82467/eigenvectors-of-real-symmetric-matrices-are-orthogonal), which is why the principal component vectors are always orthogonal. PCA could be achieved by doing an [eigendecomposition](https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix) of the covariance matrix. <br><br>Even better, instead of computing $A^T A$ and then an eigendecomposition, one can directly compute the [singular-value decomposition](https://en.wikipedia.org/wiki/Singular_value_decomposition) on the raw data matrix. SVD works for non-square matrices (unlike eigendecomposition) and produces $A = U S V^T$ where $S$ is a diagonal matrix of [singular values](https://en.wikipedia.org/wiki/Singular_value) and $U$ and $V$ are [orthogonal matrices](https://en.wikipedia.org/wiki/Orthogonal_matrix). Since the transpose of an orthogonal matrix is its inverse, and basic properties of the transpose operator: $A^T A = V S U^T U S V^T = V S S V^T =  V \Lambda V^T$, where $\Lambda$ is just a diagonal matrix of eigenvalues, which are simply the squared singular values in $S$. Thus, doing the SVD on the raw data directly gives you the eigendecomposition of the covariance matrix.
</p>
<p class="footnotes" markdown="1">
{% include foot_bottom.html n=3 %} Check out Appendix A of [Madeleine Udell's thesis](https://courses2.cit.cornell.edu/mru8/doc/udell15_thesis.pdf), which showcases five equivalent formulations of PCA as optimization problems.
</p>
<p class="footnotes" markdown="1">
{% include foot_bottom.html n=4 %} Drop it into conversation at parties. You'll sound smart and not at all obnoxious.
</p>
<p class="footnotes" markdown="1">
{% include foot_bottom.html n=5 %} In fact, one way of solving PCA is to solve an equivalent [ridge regression](https://en.wikipedia.org/wiki/Tikhonov_regularization) problem ([Zou et al., 2005](https://web.stanford.edu/~hastie/Papers/spc_jcgs.pdf)). The biggest conceptual difference is that there is no distinction between *dependent* and *independent* variables &mdash; in PCA all the $p$ variables/features are placed on equal footing. 
</p>
<p class="footnotes" markdown="1">
{% include foot_bottom.html n=6 %} It is worth mentioning that there are other ways of measuring dimensionality. One elegant way is use the eigenvalues of the covariance matrix ($\lambda_i$) to calculate the **participation ratio:**
$$
PR = \frac{\left(\sum_i \lambda_i \right)^2}{\sum_i \lambda_i^2},
$$
which is easy to work with analytically and has a number of nice properties. Suppose we have a $d \times d$ covariance matrix. If all eigenvalues are equal, $\lambda_i = \lambda$, then $PR = d$ indicating that the variance is evenly spread across all dimensions. As a second example, suppose the eigenvalues exponentially decay with rate $1/k$, i.e. $\lambda_i = \lambda \exp(-i / k)$. A small decay rate means that more components are needed to explain a fixed fraction of the variance. Thus, a larger $k$ corresponds to a more complex, higher-dimensional dataset. For this scenario, $PR$ gives a intuitively reasonable measure of dimensionality since $PR \approx 2k$ when $k$ is small relative to $d$ and $k>1$ (the top $2k$ components explain $\sim$86% of the variance).
</p>
<p class="footnotes" markdown="1">
{% include foot_bottom.html n=7 %} Optimal in this setting means minimizing the mean squared error in the limit as $n \rightarrow \infty$. This condition is necessary for the math to work out, but their procedure does quite well for finite $n$ in numerical simulations.
</p>
<p class="footnotes" markdown="1">
{% include foot_bottom.html n=8 %} The result doesn't hold if: (a) you have missing data, (b) you have a different noise model (e.g. substituting logistic loss for squared error), or (c) if you impose other constraints on the optimization problem (e.g. in nonnegative matrix factorization or sparse PCA).
</p>
